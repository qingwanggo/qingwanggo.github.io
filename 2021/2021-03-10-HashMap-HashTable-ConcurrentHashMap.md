

## HashMap

参考：[Java 8系列之重新认识HashMap](https://tech.meituan.com/2016/06/24/java-hashmap.html)

[Hash算法及常见碰撞解决方法](https://zhuanlan.zhihu.com/p/79164141)

### HashMap的实现原理？

1. 对`key`进行`hashCode()`方法，返回的值再进行`高位运算`和`取模运算`用于找到数组的位置存放Node对象，**bucket中储存键对象和值对象，作为Map.Node** ，Java8链表长度>=7时转为红黑树。
2. 线程不安全，接受null为键值；
3. 初始size为**16**，扩容：newsize = oldsize*2，size一定为2的n次幂；
4. 当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀；扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入。

### `hash碰撞`是什么？

- `key`定位到相同的位置，需要放在同一个`bucket`中。
- 碰撞后该`bucket`（键值）会以链表的方式链到后面。

### 怎么解决`hash碰撞`?

#### 1.开放地址法(再散列法)

> 开放地执法有一个公式:`Hi=(H(key)+di) MOD m i=1,2,…,k(k<=m-1)` 其中，m为哈希表的表长。
> di 是产生冲突的时候的增量序列。
> 如果di值可能为1,2,3,…m-1，称线性探测再散列。
> 如果di取1，则每次冲突之后，向后移动1个位置;如果di取值可能为
> 1,-1,2,-2,4,-4,9,-9,16,-16,…kk,-kk(k<=m/2)，称`二次探测再散列`。如果di取值可能为> 伪随机数列,称`伪随机探测再散列`。

#### 2.再哈希法Rehash

当发生冲突时，使用第二、第三个哈希函数计算地址，直到无冲突为止；

缺点：计算时间增加。

#### 3.链地址法（拉链法）

将所有关键字为同义词的记录存储在同一线性链表中。基本思想:将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。对比JDK 1.7 hashMap的存储结构是不是很好理解。至于1.8之后链表长度>=7rehash 为树形结构不在此处讨论。

##### 优点

1. 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
2. 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
3. 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
4. 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

##### 缺点

指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。

### 4.建立一个公共溢出区

> 假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。

### HashTable

- 底层数组+链表实现，无论key还是value都**不能为null**，线程**安全**，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化；
- 初始size为**11**，扩容：newsize = olesize*2+1；
- 计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length。

## ConcurrentHashMap

参考：[Map 综述（三）：彻头彻尾理解 ConcurrentHashMap](https://blog.csdn.net/justloveyou_/article/details/72783008)

[HashMap? ConcurrentHashMap?](https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/)

### Java7

> ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量,默认16)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。

#### put过程

1. 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。
2. 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。
3. 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。
4. 最后会解除在 1 中所获取当前 Segment 的锁。

#### get过程

> 只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。

- 由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。

- ConcurrentHashMap 的 get 方法是非常高效的，**因为整个过程都不需要加锁**。

### Java8

> 1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。
>
> `查询遍历链表效率太低。`

底层组成结构:

![](https://i.loli.net/2019/05/08/5cd1d2ce33795.jpg)

抛弃了原有的 Segment 分段锁，而采用了 `CAS + synchronized` 来保证并发安全性。

#### put过程

1. 根据 key 计算出 hashcode 。
2. 判断是否需要进行初始化。
3. `f` 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。
4. 如果当前位置的 `hashcode == MOVED == -1`,则需要进行扩容。
5. 如果都不满足，则利用 synchronized 锁写入数据。
6. 如果数量大于 `TREEIFY_THRESHOLD` 则要转换为红黑树。

#### get过程

1. 根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。
2. 如果是红黑树那就按照树的方式获取值。
3. 就不满足那就按照链表的方式遍历获取值。